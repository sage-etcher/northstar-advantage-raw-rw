; IMPORT TIMER.ASM

IO$CONTROL$REG	EQU	0F0H
IO$STATUS$REG1	EQU	0E0H
IO$STATUS$REG2	EQU	0D0H
SHOW$SECTOR	EQU	0$0000$0000B
DRIVE$MOTOR	EQU	0$0000$0101B
AQUIRE$MODE	EQU	0$0000$1000B
SECTOR$MOTOROFF	EQU	00EH
TRACK$ZERO	EQU	0$0010$0000B

IO$DISK$DATA	EQU	080H
I$SYNC$BYTE	EQU	081H
O$DRIVE$CONTROL	EQU	081H
IO$READ$FLAG	EQU	082H
O$WRITE$FLAG	EQU	083H

SIDE$SELECT	EQU	0$0100$0000B
STEP$DIRECTION	EQU	0$0010$0000B
PRECOMPENSATION	EQU	0$0010$0000B
STEP$PULSE	EQU	0$0001$0000B
DRIVE$ONE	EQU	0$0000$0001B
DRIVE$TWO	EQU	0$0000$0010B


;DATA
;SHOULD BE MOVED TO DATA SECTION BUT FOR NOW ITS EASIER HERE
RAW$W$DRIVE_CONTROL:	DS	1
RAW$W$TRACK:		DS	1
RAW$W$DATA_ADDR:	DS	2
RAW$W$NBLOCKS:		DS	2

RAW$WRITE:
	;FOLLOWING THE PROCEDURE OUTLINE IN SECTION 3.7

	;REG B = DRIVE CONTROL REGISTER VALUE
	;REG C = TRACK TO START WRITING AT
	;REG DE = IN BLOCKS, SIZE OF DATA TO WRITE
	;REG HL = ADDR OF DATA

	; SAVE PARAMETERS TO GLOBAL VARIABLES
					;STORE THE DRIVE_CONTROL REG VALUE
	LXI	H,RAW$W$DRIVE_CONTROL	;LOAD VARIABLE ADDRESS
	MOV	M,B			;STORE THE VALUE INTO THE VARIABLE

					;STORE THE TRACK
	LXI	H,RAW$W$TRACK		;LOAD VARIABLE ADDRESS
	MOV	M,C			;STORE THE VALUE INTO THE VARIABLE

					;STORE THE DATA_ADDRESS	
	SHLD	RAW$W$DATA_ADDR		;STORE HL INTO VARIABLE

					;STORE THE DATA BLOCK SIZE
	XCHG				;MOVE VALUE INTO HL
	SHLD	RAW$W$NBLOCKS		;STORE HL IN VARIABLE

	
	;START PREPARING TO WRITE TO THE DISK
	CALL	POWERON$INIT		;INITIALIZE POWER-ON SEQ. FOR DRIVES
	CALL	MOTOR$START		;START THE MOTOR

	LDA	RAW$W$DRIVE_CONTROL	;LOAD THE DRIVE_CONTROL VALUE
	OUT	O$DRIVE$CONTROL		;OUTPUT TO THE DRIVE CONTROL REG

	LXI	H,RAW$W$DRIVE_CONTROL	;HL = DRIVE_CONTROL VAR ADDR
	MOV	B,M			;LOAD THE VARIABLE'S VALUE INTO B
	LXI	H,RAW$W$TRACK		;HL = TRACK VAR ADDR
	MOV	C,M			;LOAD THE VARIABLE'S VALUE INTO C
	CALL	SEEK			;SEEK TO THE GIVEN TRACK



	CALL	MOTOR$STOP		;STOP THE MOTOR

	RET

SET$READ$FLAG:
	; TABLE 3-15 SET THE READ FLAG
	MVI	A,1
	OUT	IO$READ$FLAG
	RET

CLEAR$READ$FLAG:
	; TABLE 3-15 CLEAR THE READ FLAG
	IN	IO$READ$FLAG
	RET

POWERON$INIT:
	; 3.7.1 POWER-ON INITIALIZATION	

	;SETUP PARAMETERS FOR WAIT/SLEEP CALLS
	MVI	C,100			;SPECIFY 100 ITERATIONS
	MVI	B,SLEEPMILI		;OF 1 MILLISECOND WAITS

	;CYCLE THE READ FLAG
	CALL	POWERON$CYCLE$FIRST	;CYCLE #1 (NO BEGINNING WAIT)
	CALL	POWERON$CYCLE		;CYCLE #2
	CALL	POWERON$CYCLE		;CYCLE #3
	CALL	POWERON$CYCLE		;CYCLE #4
	CALL	POWERON$CYCLE		;CYCLE #5
	RET
POWERON$CYCLE:
	CALL	SLEEP			;WAIT 100 MILLISECONDS
	;FALL-THROUGH
POWERON$CYCLE$FIRST:			;DONT WAIT ON FIRST CALL
	CALL	SET$READ$FLAG		;SET THE READ FLAG
	CALL	SLEEP			;WAIT 100 MILLISECONDS
	CALL	CLEAR$READ$FLAG		;CLEAR THE READ FLAG
	RET

MOTOR$START:
	; 3.7.2 MOTOR ENABLE

	;START BOTH DISK DRIVE MOTORS
	;STOP THE MOTORS USING THE MOTOR$STOP PROCEDURE

	MVI	A,DRIVE$MOTOR		;START DISK DRIVE MOTOR COMMAND NUMBER
	OUT	IO$CONTROL$REG		;START THE MOTORS

	RET

MOTOR$STOP:
	; 3.7.2 MOTOR ENABLE

	;STOP THE DISK DRIVE MOTORS AND WAIT FOR THEM TO STOP.

	MVI	A,SHOW$SECTOR		;SHOW SECTOR COMMAND NUMBER
	OUT	IO$CONTROL$REG		;OVERWRITE THE START DRIVE MOTOR CMD
					;INSTEAD, GET THE SECTOR NUMBER
					;IF THE SECTOR # IS SECTOR$MOTOROFF
					;THEN THE MOTORS HAVE STOPPED.

	IN	IO$STATUS$REG2		;READ THE OUTPUT OF SHOW$SECTOR
	ANI	0$0000$1111B		;WE ONLY CARE ABOUT THE LOWER 4BITS
	CPI	SECTOR$MOTOROFF		;CHECK THE MOTOR IS OFF
	JNZ	MOTOR$STOP		;IF IT ISN'T CHECK AGIN UNTIL IT IS

	;WAIT 100 MICROSECONDS TO ALLOW THE DRIVES TO FINISH ALL READ/WRITES
	MVI	C,2			;2 ITERATIONS
	MVI	B,SLEEPMICRO		;OF 50 MICROSECOND WAITS
	CALL	SLEEP			;SLEEP FOR (2*50) 100 MICROSECONDS

	RET


;DATA
SEEK$DRIVE_CONTROL:	DS	1
SEEK$TRACK:		DS	1

SEEK:
	; 3.7.4 SEEK

	;REG B = DRIVE CONTROL REG VALUE
	;REG C = TRACK NUMBER

	;STORE PARAMETERS
	LXI	H,SEEK$DRIVE_CONTROL	;HL = VARIABLE ADDRESS
	MOV	M,B			;STORE THE VALUE IN IT

	LXI	H,SEEK$TRACK		;HL = VARIABLE ADDRESS
	MOV	M,C			;STORE THE VALUE IN IT

	;CODE STUFF
	LDA	SEEK$DRIVE_CONTROL	;LOAD VALUE OF DRIVE_CONTROL
	CALL	HEAD$INIT		;MOVE HEAD TO TRACK 0

	LDA	SEEK$DRIVE_CONTROL	;LOAD VALUE OF DRIVE_CONTROL
	LXI	H,SEEK$TRACK		;HL = SEEK$TRACK ADDR
	MOV	B,M			;LOAD VALUE OF SEEK$TRACK INTO REG B
	CALL	TRACK$MOVE		;MOVE N TRACKS

					;LET THE HEADS SETTLE
	MVI	C,20			;SLEEP 20 ITERATIONS
	MVI	B,SLEEPMILLI		;OF 1 MILLISECOND
	CALL	SLEEP			;SLEEP NOW

	RET


HEAD$INIT:
	;MOVE TO TRACK 0

	;REG ACC = DRIVE_CONTROL VALUE

	;VARIABLES
	ANI	0FFH-STEP$DIRECTION	;SET THE DIRECTION TO OUTER
	
	ORI	STEP$PULSE		;SET THE PUSLE BIT TO 1
	MOV	B,A			;STORE THE ON_PULSE TO REG B

	ANI	0FFH-STEP$PULSE		;SET THE PULSE BIT TO 0
	MOV	C,A			;STORE THE OFF_PULSE TO REG C

	;CODE
	;FALL-THROUGH
HEAD$INIT$LOOP:
	IN	IO$STATUS$REG1		;GET REGISTER 1 STATUS
	ANI	TRACK$ZERO		;CHECK IF WE ARE AT TRACK 0
	RNZ				;IF WE ARE, RETURN

	PUSH	B 
	CALL	CYCLE$PULSE		;SEND A STEP PULSE
	POP	B
	
	JMP	HEAD$INIT$LOOP		;LOOP UNTIL WE ARE AT TRACK 0


CYCLE$PULSE:
	;REG B = ON PULSE
	;REG C = OFF PULSE

	MOV	A,B			;PREPARE THE PULSE_ON VALUE
	OUT	O$DRIVE$CONTROL		;OUTPUT IT TO DRIVE CONTORL

	MOV	A,C			;PREPARE THE PULSE_OFF VALUE
	OUT	O$DRIVE$CONTROL		;OUTPUT IT TO DRIVE CONTORL

	MVI	C,5			;SPECIFY 5 ITERATION
	MVI	B,SLEEPMILLI		;OF 1 MILLISECOND WAITS
	CALL	SLEEP			;SLEEP FOR 5 MILLISECONDS

	RET


;DATA
TRACK$I		DS	1

TRACK$MOVE:
	;REG ACC = DRIVE_CONTROL
	;REG B = TRACK
	
	;PARAMETERS
	LXI	H,TRACK$I		;LOAD VARIABLE ADDR
	MOV	M,B			;STORE THE PARAM IN TRACK$I

	;VARIABLES
	ORI	STEP$DIRECTION		;SET THE DIRECTION TO INNER

	ORI	STEP$PULSE		;SET THE PUSLE BIT TO 1
	MOV	B,A			;STORE THE ON_PULSE TO REG B

	ANI	0FFH-STEP$PULSE		;SET THE PULSE BIT TO 0
	MOV	C,A			;STORE THE OFF_PULSE TO REG C

	;CODE
	;FALL-THROUGH
TRACK$LOOP:
	LXI	H,TRACK$I		;LOAD VARIABLE ADDRESS
	MOV	A,M			;LOAD VARIABLE VALUE INTO ACC
	CPI	0			;CHECK IF THE VALUE IS 0
	RZ				;IF IT IS, RETURN
	DCR	A			;OTHERWISE, DECREMENT THE VALUE
	MOV	M,A			;AND STORE IT BACK IN THE VARIABLE

	PUSH	B			;STORE THE PULSE VALUES ON THE STACK
	CALL	CYCLE$PULSE		;STEP 1 TRACK INWARD
	POP	B			;RESTORE THE PULSE VALUES TO BC

	JMP	TRACK$LOOP		;THEN LOOP BACK UNTIL WE REACH 0





